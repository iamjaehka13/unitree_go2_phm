Motor-10 Bias Before/After Comparison (2026-02-26)
===================================================

0) 목적
-------
과거에 관측된 "motor id=10 편향"(특정 모터에서만 성능 붕괴)이,
학습 분포 개선(미러-균등 샘플링 + step-hold) 이후 실제로 완화/해소되었는지
수치로 확인한다.


1) 과거에 어떤 현상이 있었는가
-------------------------------
[근거 파일]
- unitree_go2_phm/scripts/rsl_rl/eval_results/reval_motorfix_from_env_6996_motor_sweep_standard.json

[핵심 지표: critical/survived]
- baseline:
  - mean=0.4383, std=0.3829, min=0.0
  - worst_motor_id=10, worst_value=0.0
  - pair_gap_7_10=1.0 (7번은 생존, 10번은 붕괴)
  - values_by_motor:
    0:0.20, 1:0.56, 2:0.36, 3:0.67, 4:0.57, 5:0.91,
    6:0.99, 7:1.00, 8:0.00, 9:0.00, 10:0.00, 11:0.00
- realobs:
  - mean=0.0658, std=0.2153, min=0.0
  - worst_motor_id=1 (동률 구간 존재)
  - pair_gap_7_10=0.0

[해석]
- baseline에서는 7<->10 미러 페어 불균형이 매우 컸다(pair_gap 1.0).
- 즉, "10번 모터만 유독 약함"이라는 편향 주장에 근거가 있었다.


2) 무엇을 바꿨는가 (해결 방법)
---------------------------
A. single_motor_random 샘플링 방식을 미러-균등으로 변경
- 페어 먼저 균등 선택: (0,3),(1,4),(2,5),(6,9),(7,10),(8,11)
- 페어 내부 좌/우를 50:50 선택
- 구현 위치:
  - unitree_go2_phm/source/unitree_go2_phm/unitree_go2_phm/tasks/manager_based/unitree_go2_phm/phm/interface.py

B. step-hold 적용
- 선택된 fault motor를 일정 step 동안 유지해서
  reset 길이 차이로 인한 step 기여 불균등을 줄임
- 설정: phm_fault_hold_steps=1000

C. 실제 8k 학습 런에서 설정이 켜졌는지 로그로 검증
- baseline_fromscratch_8k_s45.log:
  - [Train] Overriding phm_fault_pair_uniform_enable=True
  - [Train] Overriding phm_fault_hold_steps=1000
- realobs_fromscratch_8k_s45.log:
  - [Train] Overriding phm_fault_pair_uniform_enable=True
  - [Train] Overriding phm_fault_hold_steps=1000


3) 현재 상태는 어떻게 됐는가
-------------------------
[신규 검증 런]
- 출력 폴더:
  - unitree_go2_phm/scripts/rsl_rl/eval_results/bias_check_8k_motor_sweep_20260225
- 요약 파일:
  - unitree_go2_phm/scripts/rsl_rl/eval_results/bias_check_8k_motor_sweep_20260225/bias_check_summary.json
- 조건:
  - checkpoint: 8k(7999)
  - scenario/protocol: critical, safety_only
  - command: forced_walk vx=0.10, yaw=0
  - eval_fault_mode: single_motor_fixed, motor_id=0..11 전체 스윕
  - num_envs=4, num_episodes=4 (quick check)

[결과: survival_per_id]
- baseline:
  - {0:1.0, 1:1.0, 2:1.0, 3:1.0, 4:1.0, 5:1.0, 6:1.0, 7:1.0, 8:0.25, 9:1.0, 10:1.0, 11:1.0}
  - mean=0.9375, std=0.2073, min=0.25, worst_motor_id=8
  - pair_gap_7_10=0.0
  - id10_minus_mean_survival=+0.0625
- realobs:
  - {0:1.0, 1:1.0, 2:1.0, 3:0.75, 4:1.0, 5:1.0, 6:1.0, 7:1.0, 8:1.0, 9:1.0, 10:1.0, 11:1.0}
  - mean=0.9792, std=0.0691, min=0.75, worst_motor_id=3
  - pair_gap_7_10=0.0
  - id10_minus_mean_survival=+0.0208

[샘플러 이론 검증]
- 같은 미러-균등 로직으로 240000 샘플 몬테카를로:
  - expected_uniform=1/12=0.08333
  - max_abs_freq_error=0.001204 (약 0.12%p)
- 해석: 샘플러 설계 자체는 id별 거의 균등 분포를 만족.


4) 결론
-------
- "motor 10만 유독 붕괴" 현상은 현재 8k 모델 quick sweep 기준으로 재현되지 않았다.
- baseline/realobs 모두 pair_gap_7_10=0.0이고, id10 survival=1.0이다.
- 즉, 과거의 id10 편향 핵심 증상은 완화/해소된 것으로 판단된다.
- 다만 baseline에서는 현재 worst id가 8로 이동했고,
  realobs에서는 worst id가 3으로 관측되어,
  "특정 id 약점" 자체는 다른 위치에서 남아 있을 수 있다.


5) 중요한 주의사항 (엄밀성)
-------------------------
이번 비교는 완전 동일 프로토콜 A/B가 아니다.
- 과거 요약: from_env 기반 6996 결과
- 현재 quick check: critical safety_only + forced_walk(vx=0.10, yaw=0), num_episodes=4

따라서 논문 최종 결론용으로는 아래를 추가 권장:
1) 동일 프로토콜(명령 분포/에피소드 수/seed)로 old vs new 재평가
2) num_episodes를 50 이상으로 확장
3) mean/std뿐 아니라 min/p10/worst-case와 pair_gap(특히 7-10) 동시 보고


6) 한 줄 요약
-----------
과거엔 baseline에서 7-10 pair gap이 1.0까지 벌어졌고 worst가 motor 10이었지만,
현재 8k 기준 검증에서는 pair_gap_7_10=0.0, id10 survival=1.0으로
"motor 10 편향" 증상은 해소된 상태로 보인다.
