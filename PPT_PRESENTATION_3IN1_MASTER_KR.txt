Unitree Go2 PHM
PPT + 발표 원고 + 코드 질의 대응 통합 마스터
작성일: 2026-02-14

========================================================================
문서 목적
========================================================================

이 문서는 아래 3개를 자연스럽게 통합한 단일 발표 운영 문서입니다.
1) PPT 구성안 (메인 22장 + 백업 16장)
2) 슬라이드별 문장형 발표 원고
3) 코드 질의 대응용 상세 기술 근거

이번 개정의 핵심:
- 기존처럼 "파일 경로 나열"에서 끝내지 않습니다.
- 각 슬라이드마다 아래를 반드시 포함합니다.
  1) 실행 위치(어디서 시작되는가)
  2) 역할 코드(어떤 함수/클래스가 무슨 책임인가)
  3) 입력/상태(무엇을 읽어 계산하는가)
  4) 출력/부작용(무엇을 바꾸고 무엇이 로그로 남는가)
  5) 교수님 질의 포인트 + 표준 답변

========================================================================
근거 논문 기준선 (하이퍼/커리큘럼/DR)
========================================================================

발표 중 "왜 이 범위로 잡았는가?" 질문이 나오면 아래 3개를 고정 근거로 답변합니다.

1) Learning to Walk in Minutes (arXiv:2109.11978)
- 링크: https://arxiv.org/abs/2109.11978
- 채택 항목: 대규모 병렬 학습 철학, curriculum + DR 프레임, 4096급 env 규모

2) legged_gym (ETH 공개 구현)
- 링크: https://github.com/leggedrobotics/legged_gym
- 채택 항목: PPO 실무 기본값 관행(`n_steps=24`, entropy 기본 세팅)

3) Curriculum Jumping for Quadrupeds (arXiv:2401.16337)
- 링크: https://arxiv.org/abs/2401.16337
- 채택 항목: DR 상한선 감각(질량/지연/마찰/오프셋)
- 주의: 점프 과제이므로 Go2 보행에는 그대로 복사하지 않고 축소 적용

우리 프로젝트 반영 원칙(고정 문장):
- "PPO 기본값은 2109.11978/legged_gym 관행을 따르고, DR 상한은 2401.16337을 참고하되 Go2 보행 안정성을 위해 보수적으로 축소했다."

========================================================================
0. 발표 전에 반드시 맞춰야 할 코드 사실(고정)
========================================================================

0.1 태스크 등록(3종)
- 등록 파일:
  `unitree_go2_phm/source/unitree_go2_phm/unitree_go2_phm/tasks/manager_based/unitree_go2_phm/__init__.py`
- `Unitree-Go2-Phm-v1` 등록: line 15
- `Unitree-Go2-Baseline-v1` 등록: line 25
- `Unitree-Go2-RealObs-v1` 등록: line 35

0.2 Distillation 기본 정책
- 파일:
  `unitree_go2_phm/scripts/rsl_rl/distill_teacher_student.py`
- 핵심: `--align_student_dynamics` 기본은 `none`
- 정렬 로직 함수: `_align_student_dynamics_with_teacher(...)` line 206
- 논문/발표 문구: "기본은 student semantics 유지, 필요 시 ablation으로 all"

0.3 온도 semantics 표기
- 평가 파일:
  `unitree_go2_phm/scripts/rsl_rl/evaluate.py`
- semantics 결정: line 823 (`case_proxy` vs `coil_hotspot`)
- 결과 키:
  - `final_max_temp_case_proxy`
  - `final_max_temp_coil_hotspot`
  - `final_max_temp`(legacy)

0.4 RealObs 전압/온도 기준
- 파일:
  `unitree_go2_phm/source/unitree_go2_phm/unitree_go2_phm/tasks/manager_based/unitree_go2_phm/unitree_go2_realobs_env_cfg.py`
- brownout 소스: `sensor_voltage` line 156
- thermal reward warn: 65C line 108
- thermal termination: case-proxy 72C line 120-122

0.5 Governor 수식 기준(시뮬/실로봇 동일 축)
- 파일:
  `unitree_go2_phm/scripts/rsl_rl/replay_utils.py`
- `GovernorConfig` 임계값: line 183-199
- `ThermalVoltageGovernor.step(...)` 계산: line 225-272

========================================================================
1. 교수님 미팅 운영 규칙(발표자가 먼저 잡아야 하는 프레임)
========================================================================

1) "아이디어"보다 "코드-실험 근거"를 먼저 제시한다.
2) 질문이 나오면 슬라이드가 아니라 즉시 함수 책임으로 답한다.
3) 온도는 항상 semantics(coil/case)를 같이 말한다.
4) Baseline은 "PHM 물리 동일 + 정보 제거"라는 공정비교 프레임으로 고정한다.
5) Distill은 "사전행동 모사"이고 최종 성능은 student task 재학습 결과로 본다.

========================================================================
2. End-to-End 코드 흐름(한 장 요약용)
========================================================================

2.1 학습 경로(train)
- 엔트리:
  `unitree_go2_phm/scripts/rsl_rl/train.py`
- 시작 함수: `main(...)` line 127
- 흐름:
  1) cfg/seed/device 설정
  2) `gym.make(task, cfg=env_cfg)` line 199
  3) `RslRlVecEnvWrapper` line 228
  4) `OnPolicyRunner`/`DistillationRunner` 생성 line 255-258
  5) `runner.learn(...)` line 281

2.2 환경 스텝 경로(env)
- 엔트리:
  `.../unitree_go2_phm_env.py`
- 핵심 함수: `UnitreeGo2PhmEnv.step(...)` line 292
- 내부:
  1) action 처리 + 센서 refresh
  2) substep0 brownout/thermal-limit/degradation 적용
  3) sim.step + `update_phm_dynamics(...)`
  4) termination/reward/obs 계산
  5) reset 시 terminal snapshot 사용

2.3 PHM 물리 경로(interface + models)
- 엔트리:
  `.../phm/interface.py`
- 핵심:
  - `update_phm_dynamics(...)` line 181
  - `update_fatigue_index(...)` (`degradation.py` line 21)
  - `update_motor_temperature(...)` (`thermal.py` line 29)

2.4 시나리오 평가 경로(evaluate)
- 엔트리:
  `unitree_go2_phm/scripts/rsl_rl/evaluate.py`
- 핵심:
  - `apply_scenario(...)` line 387
  - `run_evaluation(...)` line 533
  - semantics 메타 저장 line 859-873

2.5 고정 커맨드/거버너 경로(evaluate_replay)
- 엔트리:
  `unitree_go2_phm/scripts/rsl_rl/evaluate_replay.py`
- 핵심:
  - governor 구성 line 366-383
  - trial loop line 392 onwards
  - hard-stop reason 분류 line 511-520

2.6 teacher-student 경로(distill)
- 엔트리:
  `unitree_go2_phm/scripts/rsl_rl/distill_teacher_student.py`
- 핵심:
  - 동역학 정렬 여부 결정 line 283-292
  - DAgger beta 혼합 line 347-376
  - mismatch reset line 383-391

2.7 실로봇 브릿지 경로(C++)
- 엔트리:
  `unitree_go2_phm/scripts/real/sdk2_bridge/go2_udp_bridge.cpp`
- 핵심:
  - LowState 수신 -> `Sample` 변환 line 214-253
  - 50Hz loop/상태 송신 line 303-341
  - command polling/apply line 394-430

========================================================================
3. 메인 덱 22장 (슬라이드별 상세 원고 + 코드 질의 대응)
========================================================================

공통 형식:
- 슬라이드 목적
- 화면 구성
- 핵심 메시지
- 발표 원고 (5~8줄)
- 코드 근거/질의 포인트 (상세)
  A) 실행 엔트리
  B) 역할 코드
  C) 입력/상태
  D) 출력/부작용
  E) 교수님 예상 질문/표준 답변

----------------------------------------------------------------------
M01. 제목
----------------------------------------------------------------------
슬라이드 목적:
- 주제와 평가 축(성능+안전+열화강건성)을 10초 내 고정

화면 구성:
1) PHM-aware Robust Locomotion for Unitree Go2
2) 이름/소속/날짜
3) 부제: "Thermal-Voltage-Degradation Aware Policy"

핵심 메시지:
- "잘 걷기"가 아니라 "나빠진 상태에서도 무너지지 않기"를 다룬다.

발표 원고:
1) "오늘은 Go2 보행정책을 PHM 관점으로 재정의한 내용을 설명드리겠습니다."
2) "핵심은 최고속도보다 열화 상황에서의 생존성과 안전성입니다."
3) "코드 구조, 실험 설계, 실로봇 전이 리스크를 하나의 증거 흐름으로 보여드리겠습니다."
4) "중간에 질문 주셔도 함수 책임 단위로 바로 답변드리겠습니다."
5) "마지막에는 논문 실행을 위한 의사결정 3가지를 요청드리겠습니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- 태스크 등록 시작점:
  `.../__init__.py:15`, `.../__init__.py:25`, `.../__init__.py:35`

B) 역할 코드
- 세 태스크를 Gym ID로 등록하고, 각기 다른 env_cfg/runner_cfg를 연결한다.

C) 입력/상태
- task 문자열(`Unitree-Go2-Phm-v1` 등)
- registry kwargs(`env_cfg_entry_point`, `rsl_rl_cfg_entry_point`)

D) 출력/부작용
- 학습/평가 스크립트에서 task ID를 넣으면 올바른 환경 구성이 로드된다.

E) 예상 질문/표준 답변
Q) "3개 태스크 차이를 코드로 어디서 보나요?"
A) "`.../__init__.py`에서 등록 줄이 완전히 분리되어 있고, 각 줄이 다른 env cfg로 매핑됩니다."

----------------------------------------------------------------------
M02. 아젠다
----------------------------------------------------------------------
슬라이드 목적:
- 발표 흐름을 코드 증거 중심으로 잠그기

화면 구성:
1) 문제정의
2) 코드구조
3) 실험설계
4) sim-to-real
5) 의사결정

핵심 메시지:
- "무엇을 주장하는지"보다 "어떤 코드가 그 주장을 지지하는지"를 따라간다.

발표 원고:
1) "문제 정의 후 즉시 코드 책임 분해로 들어가겠습니다."
2) "그 다음 실험이 공정하게 설계됐는지, 재현 가능한지 보여드리겠습니다."
3) "실로봇 전이의 위험요소는 숨기지 않고 별도 섹션에서 분리 설명하겠습니다."
4) "마지막엔 교수님 의사결정 항목만 남기고 정리하겠습니다."
5) "즉, 오늘 발표는 승인 가능한 실행계획 문서라고 보시면 됩니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- 실험 정본 가이드:
  `EXPERIMENT_GUIDE.md`

B) 역할 코드
- 실험 명령, 출력 파일, 해석 규칙을 단일 문서로 고정한다.

C) 입력/상태
- task, checkpoint, seed, output_dir, replay command file

D) 출력/부작용
- 실행자마다 다른 방식으로 돌려도 결과 해석 프레임이 유지된다.

E) 예상 질문/표준 답변
Q) "왜 문서를 먼저 보여주나요?"
A) "코드만 보면 실행자마다 해석이 달라질 수 있어, 실험-해석 계약을 먼저 고정합니다."

----------------------------------------------------------------------
M03. 문제 정의
----------------------------------------------------------------------
슬라이드 목적:
- PHM 문제가 기존 locomotion 문제와 어떻게 다른지 명확화

화면 구성:
1) healthy/critical 성능 곡선
2) 온도/전압/열화 아이콘

핵심 메시지:
- 건강 상태에서의 성능 비교는 의미가 제한적이며, 열화 상태에서의 붕괴 경향을 봐야 한다.

발표 원고:
1) "Healthy에선 대부분 정책이 비슷하게 좋아 보입니다."
2) "하지만 고온/저전압/마모가 겹치면 추종오차와 포화가 급격히 증가합니다."
3) "실제 운용에서 실패는 이 구간에서 발생하므로, 평가축을 여기에 맞춰야 합니다."
4) "따라서 우리는 열화 시나리오를 강제로 주입하고 survival까지 같이 봅니다."
5) "이게 PHM 타겟 학회에서 요구하는 문제정의입니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- 시나리오 주입 함수:
  `unitree_go2_phm/scripts/rsl_rl/evaluate.py:387`

B) 역할 코드
- `apply_scenario(...)`가 fatigue/temp/soc를 직접 주입해 상태를 강제한다.
- `collect_step_metrics(...)`가 tracking/power/temp/soc/saturation을 수집한다(`evaluate.py:459`).

C) 입력/상태
- scenario별 range dict: fatigue_range, temp_range, soc_range
- env.phm_state 텐서들

D) 출력/부작용
- 평가 루프에서 동일한 시나리오 강도로 정책을 비교 가능하게 만든다.

E) 예상 질문/표준 답변
Q) "시나리오 주입이 너무 인위적이지 않나요?"
A) "맞습니다. 그래서 목표는 절대 현실복제가 아니라, 정책 간 상대 강건성 비교를 공정하게 만드는 것입니다."

----------------------------------------------------------------------
M04. 연구 질문
----------------------------------------------------------------------
슬라이드 목적:
- 실험이 답해야 하는 질문을 3개로 제한

화면 구성:
1) Q1 PHM-aware 유효성
2) Q2 RealObs 전이성
3) Q3 Governor 실효성

핵심 메시지:
- 모든 코드/실험은 3개 질문 중 하나를 답해야 한다.

발표 원고:
1) "첫째, PHM 정보를 넣으면 정말 강건성이 올라가는가?"
2) "둘째, 실측 채널만으로도 그 효과가 유지되는가?"
3) "셋째, governor가 안전성과 성능 타협을 개선하는가?"
4) "질문을 줄이면 표/그림 해석이 명확해집니다."
5) "리뷰어 대응도 결국 이 3개 질문으로 수렴합니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- Q1/Q2: 세 task 등록(`.../__init__.py`)
- Q3: `evaluate_replay.py` governor/fault 옵션

B) 역할 코드
- task 분리로 ablation 축 생성
- replay 고정 입력으로 governor 효과 분리

C) 입력/상태
- task ID, checkpoint, replay command file, governor flag, fault params

D) 출력/부작용
- 질문별 표로 분해 가능한 JSON/CSV 산출

E) 예상 질문/표준 답변
Q) "Q1/Q2/Q3가 섞여 보이는데요?"
A) "입력/관측/보상/거버너 활성 조합을 분리해 실행해서 결과 파일도 분리 저장합니다."

----------------------------------------------------------------------
M05. 시스템 아키텍처
----------------------------------------------------------------------
슬라이드 목적:
- policy -> env -> phm -> reward/termination -> eval 데이터 흐름 연결

화면 구성:
1) Policy
2) Env step
3) PHM dynamics
4) Obs/Reward/Termination
5) Eval logger

핵심 메시지:
- PHM은 관측만이 아니라 실제 제어권(게인/limit)에도 개입한다.

발표 원고:
1) "정책 액션이 들어가면 환경 step에서 바로 물리와 PHM이 같이 업데이트됩니다."
2) "PHM은 상태 텐서를 통해 보상/종료뿐 아니라 실제 torque limit에도 반영됩니다."
3) "그래서 PHM이 단순 로깅 모듈이 아니라 동역학 구조의 일부입니다."
4) "평가 스크립트는 이 상태를 직접 읽어 의미있는 지표를 만듭니다."
5) "아키텍처 상 일관성이 핵심입니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- env 클래스:
  `.../unitree_go2_phm_env.py:45`
- step:
  `.../unitree_go2_phm_env.py:292`

B) 역할 코드
- `load_managers()` line 54: PHM init 연결
- `step()` line 292: dual-rate 루프
- `_apply_physical_degradation()` line 231: Kp/Kd/PhysX 게인 반영

C) 입력/상태
- `phm_state`(fatigue/temp/soc/voltage/stall 등)
- robot actuator nominal/stiffness/damping
- brownout config

D) 출력/부작용
- PhysX stiffness/damping/effort limits 실시간 변경
- reward/termination/observation이 변경된 상태를 읽음

E) 예상 질문/표준 답변
Q) "PHM이 reward만 건드리나요?"
A) "아닙니다. `write_joint_stiffness_to_sim`, `write_joint_effort_limit_to_sim`로 물리에 직접 반영합니다."

----------------------------------------------------------------------
M06. 코드 지도
----------------------------------------------------------------------
슬라이드 목적:
- 질문이 들어왔을 때 파일/함수로 즉시 이동 가능한 지도 제공

화면 구성:
1) 학습
2) 평가
3) distill
4) real scripts

핵심 메시지:
- 기능 경계가 분리돼 있어 디버깅/발표 대응이 빠르다.

발표 원고:
1) "학습은 train.py가 책임지고, 시나리오 평가는 evaluate.py가 책임집니다."
2) "고정 커맨드+거버너는 evaluate_replay.py로 완전히 분리했습니다."
3) "distill은 teacher-student 전용 스크립트로 독립했습니다."
4) "실로봇 스크립트는 scripts/real 하위에서 시뮬 코드와 분리 운영합니다."
5) "즉, 질문이 오면 해당 책임 파일로 바로 답변 가능합니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- train: `scripts/rsl_rl/train.py:127`
- evaluate: `scripts/rsl_rl/evaluate.py:533`
- replay: `scripts/rsl_rl/evaluate_replay.py:329`
- distill: `scripts/rsl_rl/distill_teacher_student.py:256`

B) 역할 코드
- train: 러너 생성/학습
- evaluate: 시나리오 강제주입 + 통계요약
- replay: 입력통제 실험 + stop reason
- distill: 행동모사 pretrain

C) 입력/상태
- CLI args + hydra cfg + checkpoint

D) 출력/부작용
- logs/, eval json/meta/csv, replay step csv, distill summary

E) 예상 질문/표준 답변
Q) "왜 한 파일로 합치지 않았나요?"
A) "실험 목적이 다른 루프를 분리해야 책임/재현성이 올라가고, 논문 그림 생성 파이프도 단순해집니다."

----------------------------------------------------------------------
M07. 태스크 3종 정의
----------------------------------------------------------------------
슬라이드 목적:
- Phm/Baseline/RealObs 차이를 코드 책임으로 설명

화면 구성:
1) Phm-v1
2) Baseline-v1
3) RealObs-v1

핵심 메시지:
- Baseline도 동일 물리를 써야 공정 비교가 된다.

발표 원고:
1) "Phm-v1은 privileged 관측을 포함한 상한선 태스크입니다."
2) "Baseline-v1은 물리는 동일하게 두고 PHM 관측/보상을 제거한 비교군입니다."
3) "RealObs-v1은 실측 가능 채널 중심으로 claim의 본선입니다."
4) "셋을 분리해야 상한선/공정비교/전이성 검증이 동시에 가능합니다."
5) "이 구조가 논문 설득력의 기본 프레임입니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- 공통 env 클래스:
  `.../unitree_go2_phm_env.py`
- cfg 분기:
  `.../unitree_go2_phm_env_cfg.py`
  `.../unitree_go2_baseline_env_cfg.py`
  `.../unitree_go2_realobs_env_cfg.py`

B) 역할 코드
- Baseline obs/reward 제거 선언: `baseline_env_cfg.py:57-63`, `102-106`
- RealObs obs/reward/termination 지정: `realobs_env_cfg.py:43-57`, `99-122`

C) 입력/상태
- task ID가 cfg 선택을 결정

D) 출력/부작용
- 동일 물리 루프에서 정책 입력정보만 달라지는 ablation 가능

E) 예상 질문/표준 답변
Q) "Baseline도 PHM 물리면 baseline이 아닌 것 아닌가요?"
A) "우리 baseline 정의는 'PHM-aware policy가 아니라 일반 policy'입니다. 물리를 바꾸면 비교가 불공정해집니다."

----------------------------------------------------------------------
M08. 한 스텝 실행 순서
----------------------------------------------------------------------
슬라이드 목적:
- step 내부 순서를 line-by-line로 설명

화면 구성:
1) action 처리
2) substep0 brownout
3) thermal limit/degradation
4) physics/update
5) reward/termination/obs

핵심 메시지:
- substep0 선적용으로 stale target/지연 brownout 문제를 줄였다.

발표 원고:
1) "스텝 시작에서 action_manager가 액션을 처리합니다."
2) "substep0에서 먼저 apply_action 후 전압예측을 수행합니다."
3) "brownout latch와 thermal limit, degradation을 적용한 뒤 물리를 진행합니다."
4) "sim.step 이후 update_phm_dynamics로 열/전압/열화를 적분합니다."
5) "마지막에 termination/reward/obs를 계산해 RL 신호를 반환합니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- `UnitreeGo2PhmEnv.step(...)`:
  `.../unitree_go2_phm_env.py:292`

B) 역할 코드
- action 처리: line 318
- refresh_phm_sensors: line 322-323
- substep loop: line 328
- brownout 계산: line 337-375
- thermal limit 적용: line 379-388
- degradation 적용: line 389-390
- dynamics 적분: line 396-397
- termination/reward: line 425-426
- obs 계산: line 442

C) 입력/상태
- `self.robot.data.joint_pos_target`, `self.phm_state.*`, brownout cfg

D) 출력/부작용
- `phm_state.brownout_scale`, `joint_effort_limits`, degraded gains 갱신
- `obs_buf`, `rew_buf`, `termination` 반환

E) 예상 질문/표준 답변
Q) "왜 substep마다 limit 재계산 안 하나요?"
A) "현재 설계는 control-step(50Hz) 기준으로 substep0에서 1회 계산해 비용을 줄이고, substep간 미세 변동을 노이즈로 보지 않게 합니다."

----------------------------------------------------------------------
M09. PHM 상태 변수
----------------------------------------------------------------------
슬라이드 목적:
- PHM state가 실제로 어떤 채널을 저장/공유하는지 제시

화면 구성:
1) thermal
2) electrical
3) mechanical
4) bias/noise

핵심 메시지:
- 관측/보상/종료가 같은 상태 텐서를 공유하므로 해석 일관성이 올라간다.

발표 원고:
1) "PHM state는 온도, 전압, SOC, fatigue, saturation, stall 등을 함께 유지합니다."
2) "각 모듈은 이 단일 상태를 읽기 때문에 해석 축이 분산되지 않습니다."
3) "리셋과 시나리오 주입 시 이 상태를 동기화해 초기 비정상치를 줄였습니다."
4) "실험 지표도 같은 상태에서 뽑아 표/그림이 일관됩니다."
5) "이 구조가 리뷰에서 많이 지적되는 모순을 줄입니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- PHM init:
  `.../phm/interface.py:67`

B) 역할 코드
- `init_phm_interface(...)`에서 `env.phm_state = PHMState(...)` 생성 line 77
- extras 연결(`joint_temp`, `joint_case_temp`) line 115-119

C) 입력/상태
- num_envs, NUM_MOTORS, device

D) 출력/부작용
- env 전체 모듈이 참조하는 shared state 생성

E) 예상 질문/표준 답변
Q) "상태가 너무 많아 오류 안 나나요?"
A) "step 시작에서 `clear_step_metrics(...)`로 누적 버퍼를 리셋하고, reset에서 scenario/state를 재동기화합니다."

----------------------------------------------------------------------
M10. Thermal 모델
----------------------------------------------------------------------
슬라이드 목적:
- coil-case 2노드 열 모델의 역할과 RealObs 연결 설명

화면 구성:
1) coil heat
2) case heat
3) cooling
4) case proxy

핵심 메시지:
- privileged(coil)와 realobs(case) 해석을 같은 모델 안에서 다룬다.

발표 원고:
1) "열 모델은 coil과 case를 분리한 2-node RC 구조입니다."
2) "coil은 권선 발열, case는 하우징/드라이버 근접 발열을 반영합니다."
3) "강제대류는 joint velocity에 비례해 case cooling을 키웁니다."
4) "RealObs는 case 기반 threshold로 해석하고, privileged는 coil 기준으로 해석합니다."
5) "이 분리 덕분에 semantics 충돌을 코드 수준에서 관리할 수 있습니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- `update_motor_temperature(...)`:
  `.../phm/models/thermal.py:29`

B) 역할 코드
- 2-node 경로 분기: line 73
- coupling/cooling 계산: line 91-99
- coil/case 업데이트: line 101-110
- fallback 1-node: line 114-137

C) 입력/상태
- `p_coil_watts`, `p_case_watts`, `coil_temp`, `motor_case_temp`, `joint_vel`

D) 출력/부작용
- coil_temp, motor_case_temp, case_temp_derivative 갱신

E) 예상 질문/표준 답변
Q) "case 온도 센서가 없으면?"
A) "fallback으로 coil-delta proxy를 사용하며, RealObs 관측/termination에서도 동일 철학으로 동작합니다."

----------------------------------------------------------------------
M11. 전압/SOC 모델
----------------------------------------------------------------------
슬라이드 목적:
- 전압 sag, SOC, brownout이 어디서 계산되고 어디서 쓰이는지 연결

화면 구성:
1) compute_battery_voltage
2) bms_pred vs sensor voltage
3) brownout hysteresis

핵심 메시지:
- 전압 모델은 전략 관측, brownout, governor를 관통하는 공통 축이다.

발표 원고:
1) "배터리 전압은 SOC와 부하전력으로 계산한 OCV+sag 모델입니다."
2) "brownout은 enter/recover 히스테리시스로 진동을 줄입니다."
3) "RealObs는 sensor_voltage 기준으로 brownout 판정합니다."
4) "전략 관측(energy budget)과 replay governor 임계값도 같은 축으로 맞췄습니다."
5) "실로그 보정에서 가장 먼저 잡아야 할 축입니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- `compute_battery_voltage(...)`:
  `.../phm/utils.py:70`
- brownout source 설정:
  `.../unitree_go2_realobs_env_cfg.py:156`

B) 역할 코드
- sag 계산: `utils.py:82-93`
- env brownout latch: `unitree_go2_phm_env.py:358-374`

C) 입력/상태
- soc, load_watts, battery_voltage channels, cfg enter/recover

D) 출력/부작용
- brownout_latched/brownout_scale 변화
- effort limit 최종 축소에 반영

E) 예상 질문/표준 답변
Q) "bms_pred와 sensor 중 어떤 게 맞나요?"
A) "연구 포지션에 따라 다릅니다. RealObs claim은 sensor 기준으로 고정하고, privileged/전략 실험은 bms_pred도 허용합니다."

----------------------------------------------------------------------
M12. Mechanical degradation 모델
----------------------------------------------------------------------
슬라이드 목적:
- fatigue 누적과 SOH/게인저하 연결 설명

화면 구성:
1) fatigue rate 식
2) vibration/thermal coupling
3) health index

핵심 메시지:
- fatigue는 단순 로그가 아니라 제어권 감소로 이어진다.

발표 원고:
1) "fatigue는 토크 부하, 속도, 진동, 열스트레스를 결합해 누적합니다."
2) "stall 구간에서도 fretting을 고려해 최소 속도 하한으로 마모를 적분합니다."
3) "누적 fatigue는 Kp/Kd/effort limit을 줄이는 경로로 연결됩니다."
4) "SOH는 초기 용량 대비 잔여치로 계산해 관측/분석에 사용합니다."
5) "즉 mechanical PHM이 동작 정책에 실제 영향을 줍니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- `update_fatigue_index(...)`:
  `.../phm/models/degradation.py:21`
- health index:
  `.../phm/models/degradation.py:121`

B) 역할 코드
- normalized load 계산 line 61-74
- stress factor 계산 line 78-88
- fatigue integration line 105-119

C) 입력/상태
- applied_torque, joint_vel, vibration_g, jitter_intensity, coil_temp

D) 출력/부작용
- fatigue_index/fatigue_rate 업데이트
- 이후 env의 degradation gain 계산에 사용

E) 예상 질문/표준 답변
Q) "fatigue가 실제 고장모델과 1:1인가요?"
A) "아니고, 현재는 제어강건성 비교용 surrogate입니다. 절대수명 예측 claim은 하지 않습니다."

----------------------------------------------------------------------
M13. 제어권 감소 경로(열화가 실제 동작을 바꾸는 곳)
----------------------------------------------------------------------
슬라이드 목적:
- reward-only 접근이 아닌 동역학적 제약 반영을 증명

화면 구성:
1) thermal derating
2) fatigue derating
3) external fault scale
4) PhysX write

핵심 메시지:
- 열화는 실제 simulator 제어 게인/limit을 바꾼다.

발표 원고:
1) "열과 fatigue로 gain factor를 계산해 Kp/Kd를 줄입니다."
2) "여기에 외부 fault profile을 곱해 재현 가능한 고장주입을 만듭니다."
3) "계산된 값을 PhysX stiffness/damping으로 직접 씁니다."
4) "동시에 effort limit도 thermal/fatigue/friction을 반영해 줄입니다."
5) "그래서 정책은 위험 상태에서 행동을 바꿀 수밖에 없습니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- `_apply_physical_degradation(...)`:
  `.../unitree_go2_phm_env.py:231`
- `_compute_thermal_limits(...)`:
  `.../unitree_go2_phm_env.py:665`

B) 역할 코드
- thermal/fatigue derating 계산: line 252-275
- external fault scale 적용: line 277-279
- PhysX write: line 289-290
- effort limit 반영: line 701-710, 729-737

C) 입력/상태
- coil_temp, fatigue_index, friction_bias, nominal kp/kd, fault scales

D) 출력/부작용
- degraded_stiffness/damping, joint_effort_limits 변경

E) 예상 질문/표준 답변
Q) "fault는 어디 다리에 어떻게 넣나요?"
A) "replay에서 `fault_leg`, `fault_kp_scale`, `fault_kd_scale`, `fault_start_s`로 고정 주입합니다."

----------------------------------------------------------------------
M14. 관측 설계 원칙
----------------------------------------------------------------------
슬라이드 목적:
- privileged와 real-observable 경계를 코드로 명확히 제시

화면 구성:
1) Phm obs 목록
2) Baseline obs 목록
3) RealObs obs 목록

핵심 메시지:
- 메인 claim은 RealObs 관측축에서만 한다.

발표 원고:
1) "Phm-v1에는 mech_health, degradation_trend 등 latent 관측이 있습니다."
2) "Baseline은 PHM 관측을 제거해 정보이득을 검증합니다."
3) "RealObs는 측정가능 채널 중심으로 제한합니다."
4) "논문 본문 성능표는 RealObs를 중심에 두겠습니다."
5) "latent는 상한선/보조분석으로 위치시킵니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- Phm obs: `phm_env_cfg.py:262-283`
- Baseline 제거: `baseline_env_cfg.py:57-63`
- RealObs obs: `realobs_env_cfg.py:43-64`

B) 역할 코드
- `available_voltage_budget_realobs`, `thermal_stress_realobs`를 관측에 사용

C) 입력/상태
- battery_voltage(sensor), case temp proxy, imu/contact derived vibration

D) 출력/부작용
- student/real policy 입력벡터가 실측 채널 중심으로 제한됨

E) 예상 질문/표준 답변
Q) "realobs인데 latent reward 쓰면 모순 아닌가요?"
A) "현재 RealObs reward는 `thermal_margin_reward_realobs`로 case 경계 기반입니다. 관측과 보상 의미를 맞췄습니다."

----------------------------------------------------------------------
M15. 보상/종료 원칙
----------------------------------------------------------------------
슬라이드 목적:
- reward 분해와 termination 계층(경고/패널티/정지) 설명

화면 구성:
1) locomotion terms
2) PHM terms
3) termination terms

핵심 메시지:
- RealObs는 warn=65, crit=70, stop=72 계층으로 정리돼 있다.

발표 원고:
1) "추종/안정화 보상에 PHM 보상을 보조로 얹는 구조입니다."
2) "RealObs thermal 관측과 reward 시작점은 65C로 통일했습니다."
3) "termination은 case-proxy 72C에서 hard stop합니다."
4) "이렇게 계층을 분리하면 정책이 급정지 전 완화 행동을 학습하기 쉽습니다."
5) "발표/논문에서 이 계층 구조를 명확히 쓰겠습니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- RealObs rewards:
  `realobs_env_cfg.py:99-114`
- RealObs termination:
  `realobs_env_cfg.py:119-122`

B) 역할 코드
- thermal reward 함수: `phm.py:123` (`thermal_margin_reward_realobs`)
- thermal termination 함수: `health.py:85` (`thermal_runaway`)

C) 입력/상태
- case temp or coil-delta proxy, warn/limit/threshold params

D) 출력/부작용
- 보상 감점과 종료신호가 동일 온도 의미축을 사용

E) 예상 질문/표준 답변
Q) "왜 stop을 70이 아니라 72로 두나요?"
A) "warn/crit 구간에서 감속·회피를 시도할 여유를 주고, 72는 실제 안전정지 경계로 사용하기 위함입니다."

----------------------------------------------------------------------
M16. 학습 프로토콜
----------------------------------------------------------------------
슬라이드 목적:
- 재현 가능한 학습 설정과 러너 흐름 설명

화면 구성:
1) seed 고정
2) env 생성
3) runner.learn
4) 체크포인트

핵심 메시지:
- 동일 예산/동일 초기조건에서 비교한다.

발표 원고:
1) "train.py에서 python/numpy/torch seed를 동시에 고정합니다."
2) "task cfg를 로드한 뒤 gym env를 생성합니다."
3) "runner는 OnPolicyRunner 또는 DistillationRunner를 사용합니다."
4) "학습 반복수와 로그 경로를 명시적으로 저장합니다."
5) "재현 가능한 학습 실험을 우선합니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- `train.py:127` (`main`)

B) 역할 코드
- seed 설정: line 140-146
- env 생성: line 199
- runner 생성: line 255-258
- learn 호출: line 281

C) 입력/상태
- CLI/hydra args: task, num_envs, max_iterations, device

D) 출력/부작용
- `logs/rsl_rl/<experiment>/<timestamp>`에 학습 산출 저장

E) 예상 질문/표준 답변
Q) "학습이 멈추면 어디부터 봐야 하나요?"
A) "`--debug_startup` 경로가 warmup/reset/step 시간을 분해 출력하므로 env 생성 vs runner 생성 병목을 바로 식별할 수 있습니다."

----------------------------------------------------------------------
M17. 시나리오 평가
----------------------------------------------------------------------
슬라이드 목적:
- 4시나리오 평가가 어떤 통계로 끝나는지 설명

화면 구성:
1) fresh/used/aged/critical
2) metric table
3) 결과 파일

핵심 메시지:
- 시나리오 강제주입 + terminal snapshot 기반 통계로 공정 비교

발표 원고:
1) "각 시나리오에서 동일 episode 수를 수집합니다."
2) "tracking/power/energy/temp/soc/survival을 episode 단위로 요약합니다."
3) "done 직전 값을 terminal snapshot으로 읽어 리셋 오염을 줄입니다."
4) "temperature semantics를 meta에 별도 저장합니다."
5) "표/캡션 자동 생성 시 오해를 줄일 수 있습니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- `run_evaluation(...)`: `evaluate.py:533`

B) 역할 코드
- episode 누적/완결 처리: line 548-758
- terminal snapshot 결합: line 598-621, 643-677
- semantics 키 추가: line 663-668

C) 입력/상태
- scenario_name, num_target_episodes, policy, env

D) 출력/부작용
- `eval_*.json`, `eval_*_meta.json`, `reward_breakdown_*.csv`

E) 예상 질문/표준 답변
Q) "done되면 값이 리셋되는데 마지막값은 어떻게 보장하나요?"
A) "env 내부 terminal snapshot(`_last_terminal_metrics`)을 평가 루프가 우선 사용합니다."

----------------------------------------------------------------------
M18. Replay + Governor 평가
----------------------------------------------------------------------
슬라이드 목적:
- 입력통제 실험으로 governor/fault 효과 분리

화면 구성:
1) replay command
2) governor on/off
3) fault on/off
4) stop reason

핵심 메시지:
- 입력을 고정하고 안전 로직만 바꿔 인과를 분리한다.

발표 원고:
1) "replay에서는 vx/vy/wz 명령을 파일에서 고정 재생합니다."
2) "governor on/off와 fault 주입 조합으로 조건별 차이를 측정합니다."
3) "hard-stop 이유(temp/pack/cell)를 분리해 기록합니다."
4) "성능은 yaw 오차, 안전은 온도/전압 노출시간과 완료율로 봅니다."
5) "이 방식이 실험 해석에서 가장 명료합니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- `evaluate_replay.py:329` (`main`)

B) 역할 코드
- governor 생성: line 366-383
- fault 적용: line 410-421
- governor step 적용: line 433-455
- hard-stop 분류: line 511-520

C) 입력/상태
- command_file, num_trials, fault params, governor params

D) 출력/부작용
- trial step CSV + summary JSON
- stop_reasons aggregate

E) 예상 질문/표준 답변
Q) "governor 수식은 어디서 정의되나요?"
A) "`replay_utils.py`의 `ThermalVoltageGovernor.step`이 단일 수식 SSOT입니다."

----------------------------------------------------------------------
M19. Teacher-Student 전이
----------------------------------------------------------------------
슬라이드 목적:
- privileged 상한 행동을 RealObs 학생으로 이전하는 절차 설명

화면 구성:
1) teacher(phm)
2) student(realobs)
3) distill + finetune

핵심 메시지:
- distill은 pretrain이고 최종 판단은 student task 재학습 결과로 한다.

발표 원고:
1) "teacher는 privileged 관측으로 상한 행동 분포를 만듭니다."
2) "student는 realobs 관측으로 teacher action을 모사합니다."
3) "DAgger beta를 낮춰 학생 행동 노출을 단계적으로 늘립니다."
4) "기본은 align none으로 student semantics를 보존합니다."
5) "이후 student RL finetune으로 실제 목표함수에 맞춥니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- `distill_teacher_student.py:256`

B) 역할 코드
- alignment 적용: line 283-292
- 명령 동기화: line 178-180, 355-357
- MSE distill: line 364-371
- DAgger 혼합: line 374-376
- mismatch reset: line 385-391

C) 입력/상태
- teacher/student task cfg, checkpoints, dagger beta schedule

D) 출력/부작용
- `student_distill_*.pt`, `distill_summary.json`

E) 예상 질문/표준 답변
Q) "align all을 쓰면 더 잘되지 않나요?"
A) "일시적으로 loss는 안정될 수 있지만 student task 의미를 덮어써 메인 claim이 약해질 수 있어 기본은 none입니다."

----------------------------------------------------------------------
M20. sim-to-real 리스크 요약
----------------------------------------------------------------------
슬라이드 목적:
- 코드가 맞아도 실기에서 깨질 수 있는 지점 명시

화면 구성:
1) semantics mismatch
2) 샘플링 mismatch
3) 명령 인터페이스 mismatch
4) 파라미터 mismatch

핵심 메시지:
- 리스크는 실패가 아니라 관리대상이며, 로그-보정-재검증 루프로 줄인다.

발표 원고:
1) "coil/case semantics 혼동은 표 해석 오류를 만듭니다."
2) "500Hz raw를 50Hz로 내릴 때 집계규칙이 결과를 바꿉니다."
3) "실기 명령 인터페이스(q_des+Kp/Kd)와 sim 명령 차이를 관리해야 합니다."
4) "온도/전압 상수는 실로그 기반 재보정이 필요합니다."
5) "이 리스크 테이블을 논문 limitation/validation 계획에 그대로 넣겠습니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- 로그 변환: `scripts/real/log_to_replay_csv.py:71`
- 오프라인 거버너 검증: `scripts/real/offline_governor_eval_from_log.py:128`

B) 역할 코드
- 500Hz->50Hz window 집계 규칙: `log_to_replay_csv.py:131-149`
- governor hard-stop 판정: `offline_governor_eval_from_log.py:190-199`

C) 입력/상태
- raw csv 컬럼(12 temp, 8 cell, pack v, cmd)

D) 출력/부작용
- replay-friendly csv + 안전지표 summary json

E) 예상 질문/표준 답변
Q) "raw 집계 규칙 왜 저렇게 고정했나요?"
A) "온도는 max, 셀전압은 min, 명령/pack은 last로 두어 안전측 보수 추정과 제어입력 동기성을 동시에 맞췄습니다."

----------------------------------------------------------------------
M21. 실로그 반영 계획
----------------------------------------------------------------------
슬라이드 목적:
- 실로봇 로그를 어떤 파일에 어떻게 연결할지 구체 절차 제시

화면 구성:
1) 수집
2) 변환
3) 보정
4) 재평가

핵심 메시지:
- 남은 핵심은 "실상수(real constants) 보정"이며, 코드 위치가 이미 정리돼 있다.

발표 원고:
1) "실로봇에서 500Hz 상태를 raw CSV로 수집합니다."
2) "표준 스크립트로 50Hz replay CSV를 생성합니다."
3) "이 분포로 warn/stop/EMA tau를 보정합니다."
4) "보정 후 replay/evaluate를 재실행해 성능과 안전지표를 갱신합니다."
5) "즉시 논문 표/그림으로 연결할 수 있습니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- SDK 체크: `scripts/real/check_sdk_setup.py:129`
- 브릿지: `scripts/real/sdk2_bridge/go2_udp_bridge.cpp:473`
- 라이브 거버너: `scripts/real/run_governor_live_template.py:344`

B) 역할 코드
- SDK 배치 검증: `validate_sdk_root(...)` line 59
- LowState->CSV UDP 송신: bridge `SendState(...)` line 432-455
- live governor 루프: python line 487 이후

C) 입력/상태
- LowState(12 motor temp, pack/cell, imu gyro)

D) 출력/부작용
- 실시간 step csv + summary json

E) 예상 질문/표준 답변
Q) "실로봇 연결 전에 뭐가 준비되어야 하나요?"
A) "SDK2 경로 검증, bridge 빌드, UDP 포트 충돌 점검, estop bit mask 정의가 필수입니다."

----------------------------------------------------------------------
M22. 결론 + 의사결정 요청
----------------------------------------------------------------------
슬라이드 목적:
- 코드 상태/남은 일/결정사항을 명확히 종료

화면 구성:
1) 현재완료
2) 남은리스크
3) 요청 3개

핵심 메시지:
- 코드 정합성 기반은 갖췄고, 이제 실로그 보정과 결과 생산 단계다.

발표 원고:
1) "현재 코드는 학습-평가-리플레이-distill-실기브릿지까지 연결된 상태입니다."
2) "남은 핵심은 실로그 기반 상수 보정과 결과표 생산입니다."
3) "오늘은 투고 타겟, fault 주입 범위, 안전 임계값 승인만 요청드립니다."
4) "승인되면 2주 안에 표/그림/캡션까지 고정 가능합니다."
5) "다음 미팅은 숫자 중심으로만 보고드리겠습니다."

코드 근거/질의 포인트(상세):
A) 실행 엔트리
- 운영 런북:
  `RUNBOOK_1_2_3_EXECUTION_KR.txt`

B) 역할 코드
- 명령 시퀀스(학습->평가->리플레이->튜닝->재평가) 고정

C) 입력/상태
- task/checkpoint/replay/log path

D) 출력/부작용
- 논문용 표/그림 소스 JSON/CSV 체인 완성

E) 예상 질문/표준 답변
Q) "지금 바로 논문 제출 가능합니까?"
A) "코드/실험틀은 가능하지만, 실로그 보정과 최소 반복실험(variance 보고)까지 끝내야 제출 안정성이 올라갑니다."

========================================================================
4. 백업 덱 16장 (질문 대응 전용 상세)
========================================================================

----------------------------------------------------------------------
B01. 태스크 등록 코드 근거
----------------------------------------------------------------------
핵심:
- registry 줄 단위로 실험군 정의를 증명

코드 근거 상세:
A) 엔트리
- `.../__init__.py:15`, `:25`, `:35`

B) 역할
- task ID별 env cfg/runner cfg 매핑

C) 질의/답변
Q) "같은 env class인데 왜 task가 다르죠?"
A) "env class는 공통이고, cfg가 관측/보상/종료 의미를 분기합니다."

----------------------------------------------------------------------
B02. Env.step call graph 상세
----------------------------------------------------------------------
핵심:
- step 순서가 왜 그런지 설명

코드 근거 상세:
A) 엔트리
- `unitree_go2_phm_env.py:292`

B) 핵심 함수/역할
- action process line 318
- brownout line 337-375
- degradation line 389-390
- phm dynamics line 397
- termination/reward/obs line 425-443

C) 질의/답변
Q) "전압예측이 액션 적용 전에 돌면?"
A) "stale target 문제가 생겨 brownout 판단이 1-step 늦어질 수 있어 현재는 apply_action을 먼저 실행합니다(line 333-334)."

----------------------------------------------------------------------
B03. reset/curriculum 로직 상세
----------------------------------------------------------------------
핵심:
- hard phase jump가 아닌 hybrid ramp + gate

코드 근거 상세:
A) 엔트리
- `interface.py:639` (`_curriculum_effective_step_with_gate`)
- `interface.py:717` (`reset_phm_interface`)

B) 역할
- termination/tracking EMA로 difficulty advance gain 결정
- scenario mixture를 step 기반으로 부드럽게 변경

C) 질의/답변
Q) "왜 1000/2000 step 급변을 피하려고 했나요?"
A) "급변은 보행 붕괴를 유도해 학습 신호가 불안정해져서, ramp+gate로 완화했습니다."

----------------------------------------------------------------------
B04. 관측 채널 비교표(파일 기준)
----------------------------------------------------------------------
핵심:
- 어떤 정책이 무엇을 보는지 코드로 명시

코드 근거 상세:
- Phm obs: `phm_env_cfg.py:262-283`
- Baseline obs 제거: `baseline_env_cfg.py:57-63`
- RealObs obs: `realobs_env_cfg.py:43-64`

질의/답변:
Q) "RealObs에서 mech_health 쓰나요?"
A) "아니요. RealObs 관측에 mech_health는 없습니다."

----------------------------------------------------------------------
B05. 보상 항목 비교표(파일 기준)
----------------------------------------------------------------------
핵심:
- reward 차이가 정책 차이를 만든다.

코드 근거 상세:
- Phm reward 활성: `phm_env_cfg.py:356-384`
- Baseline PHM reward 제거: `baseline_env_cfg.py:102-106`
- RealObs thermal reward: `realobs_env_cfg.py:105-109`

질의/답변:
Q) "reward가 많으면 오히려 못 걷지 않나요?"
A) "그래서 locomotion 항목 가중치를 유지한 상태에서 PHM 항목은 저가중치로 보조하도록 설계했습니다."

----------------------------------------------------------------------
B06. 종료 조건 비교표
----------------------------------------------------------------------
핵심:
- fall/thermal/stall 계층 분리

코드 근거 상세:
- thermal termination 함수:
  `health.py:85`
- RealObs threshold/use_case_proxy:
  `realobs_env_cfg.py:120-122`

질의/답변:
Q) "termination이 너무 빡세면 학습이 깨지지 않나요?"
A) "warn/reward/stop 계층을 분리해 조기학습에서 완화 행동을 만들고, hard-stop은 안전경계로만 씁니다."

----------------------------------------------------------------------
B07. 온도 semantics 상세
----------------------------------------------------------------------
핵심:
- 평가표에서 coil/case 혼동 방지

코드 근거 상세:
- semantics 선택: `evaluate.py:823`
- meta 저장: `evaluate.py:859-873`
- 테이블 주석: `evaluate.py:891-903`

질의/답변:
Q) "final_max_temp 하나만 쓰면 안 되나요?"
A) "task별 의미가 달라 오해를 부르므로 semantics key를 함께 저장/표기합니다."

----------------------------------------------------------------------
B08. Governor 수식 상세
----------------------------------------------------------------------
핵심:
- 수식이 어디에 고정돼 있는지 제시

코드 근거 상세:
- config 임계값: `replay_utils.py:183-199`
- step 수식:
  - temp EMA/pred: line 228-238
  - s_temp/s_volt: line 241-243
  - slew 제한: line 245-251
  - hard-stop: line 254-257

질의/답변:
Q) "yaw를 왜 더 줄이나요?"
A) "`yaw_exponent`(기본 1.5)로 회전을 더 보수적으로 줄여 전압/열 여유를 확보합니다."

----------------------------------------------------------------------
B09. Replay 명령 포맷 상세
----------------------------------------------------------------------
핵심:
- CSV/JSON/YAML 모두 동일 schedule로 정규화

코드 근거 상세:
- parser: `replay_utils.py:54-180`
- t 컬럼 있으면 dt grid 보간: line 68-79
- structured segments 확장: line 87-167

질의/답변:
Q) "command 포맷이 바뀌면 결과 재현성이 깨지나요?"
A) "정규화 parser가 동일 schedule 구조로 변환하기 때문에 포맷 차이 영향이 최소화됩니다."

----------------------------------------------------------------------
B10. sim-to-real 리스크 상세표
----------------------------------------------------------------------
핵심:
- 리스크를 항목화해 대응책과 코드 위치 연결

코드 근거 상세:
- raw->50Hz 변환 규칙: `log_to_replay_csv.py:131-149`
- offline governor 재현: `offline_governor_eval_from_log.py:183-217`
- live governor 브릿지: `run_governor_live_template.py:487` 이후

질의/답변:
Q) "실기에서 가장 먼저 깨질 축은?"
A) "보통 온도 semantics와 전압 컷 경계입니다. 그래서 이 두 축 상수 보정이 1순위입니다."

----------------------------------------------------------------------
B11. real 로그 처리 파이프라인
----------------------------------------------------------------------
핵심:
- 원본 보존과 분석 산출 분리

코드 근거 상세:
- sdk check: `check_sdk_setup.py:59`
- bridge sample 생성: `go2_udp_bridge.cpp:214`
- replay csv 변환: `log_to_replay_csv.py:71`
- offline eval: `offline_governor_eval_from_log.py:128`

질의/답변:
Q) "왜 바로 live tuning 안 하나요?"
A) "offline로 먼저 안정영역을 찾고 live에서 안전확인하는 2단계가 더 안전하고 빠릅니다."

----------------------------------------------------------------------
B12. 파일별 수정 포인트(상수 보정)
----------------------------------------------------------------------
핵심:
- 어디를 바꿔야 의미가 동시에 맞는지 표준화

코드 근거 상세:
1) 관측:
- `phm_raw.py` (`thermal_stress_realobs`, `available_voltage_budget_realobs`)
2) 보상:
- `rewards/phm.py` (`thermal_margin_reward_realobs`)
- `realobs_env_cfg.py` (reward params)
3) 종료:
- `terminations/health.py` + `realobs_env_cfg.py`
4) replay governor:
- `replay_utils.py`, `evaluate_replay.py`
5) live/offline governor:
- `run_governor_live_template.py`, `offline_governor_eval_from_log.py`

질의/답변:
Q) "한 군데만 바꿔도 되지 않나요?"
A) "그렇게 하면 관측/보상/종료 의미가 분리되어 논문 해석 모순이 생깁니다."

----------------------------------------------------------------------
B13. stop reason taxonomy
----------------------------------------------------------------------
핵심:
- 중단 원인 분리로 디버깅 가능

코드 근거 상세:
- replay stop reason 조립: `evaluate_replay.py:513-520`
- live stop reason: `run_governor_live_template.py:228-242`
- offline stop reason: `offline_governor_eval_from_log.py:190-199`

질의/답변:
Q) "넘어짐과 hard-stop을 어떻게 구분하나요?"
A) "env termination(`env_terminated`)과 governor hard-stop(`governor_hard_stop_*`)을 별도 태그로 저장합니다."

----------------------------------------------------------------------
B14. ablation 우선순위
----------------------------------------------------------------------
핵심:
- 시간 대비 정보량 높은 순서

권장 순서:
1) distill align none vs all
2) governor on vs off (same replay)
3) fault 강도 스윕(leg fixed)
4) semantics별 표기 비교

코드 근거 상세:
- distill align: `distill_teacher_student.py:206-253`
- replay on/off: `evaluate_replay.py:366`

----------------------------------------------------------------------
B15. 2주 상세 일정
----------------------------------------------------------------------
핵심:
- 실행 가능한 일정과 산출물 정의

1주차:
1) 실로그 수집 + 변환
2) 상수 1차 보정
3) 핵심 실험 1차

2주차:
1) ablation 최소셋
2) 표/그림/캡션 확정
3) 문서/FAQ 정리

----------------------------------------------------------------------
B16. FAQ 표준 답변
----------------------------------------------------------------------
핵심:
- 반복 질문에 즉답 가능한 문장 템플릿 제공

Q1) "PHM인데 왜 RL 비중이 큰가?"
A1) "PHM 신호를 제어정책에 통합해 열화강건성을 높이는 것이 문제정의라, 제어학습이 핵심 수단입니다."

Q2) "latent를 논문에서 써도 되나?"
A2) "가능하지만 본문 claim은 RealObs 중심으로 두고, latent는 상한선/보조분석으로 위치시켜야 리뷰 리스크가 낮습니다."

Q3) "governor 없는 정책만으로 충분하지 않나?"
A3) "운용 안전 경계(temp/voltage hard-stop)를 명시적으로 보장하려면 governor 레이어가 실용적입니다."

========================================================================
5. 코드 역할 매트릭스 (교수님 질의 대응용 핵심표)
========================================================================

5.1 학습/평가 스크립트

1) `train.py`
- 역할: 학습 오케스트레이션
- 핵심 함수: `main` line 127
- 읽는 것: task cfg, agent cfg, seed/device
- 쓰는 것: 학습 로그/체크포인트

2) `evaluate.py`
- 역할: 시나리오 강제주입 평가
- 핵심 함수: `apply_scenario`, `run_evaluation`, `main`
- 읽는 것: phm_state, terminal snapshot
- 쓰는 것: eval json/meta/csv

3) `evaluate_replay.py`
- 역할: 고정명령+거버너/고장 주입 실험
- 핵심 함수: `_apply_fault`, trial loop, `_summarize_rows`
- 읽는 것: replay command, phm temp/voltage
- 쓰는 것: trial csv, summary json, stop reasons

4) `distill_teacher_student.py`
- 역할: teacher action distill + DAgger
- 핵심 함수: `_align_student_dynamics_with_teacher`, `main`
- 읽는 것: teacher/student obs, commands
- 쓰는 것: student distill checkpoint, summary

5.2 환경/PHM 핵심 모듈

1) `unitree_go2_phm_env.py`
- 역할: env step/reset + 물리반영
- 핵심 함수:
  - `step` line 292
  - `_apply_physical_degradation` line 231
  - `_compute_thermal_limits` line 665
  - `_predict_instant_voltage_ivp` line 540

2) `phm/interface.py`
- 역할: PHM 적분/리셋/커리큘럼
- 핵심 함수:
  - `init_phm_interface` line 67
  - `update_phm_dynamics` line 181
  - `reset_phm_interface` line 717

3) `thermal.py`
- 역할: coil-case 열 적분
- 핵심 함수: `update_motor_temperature` line 29

4) `degradation.py`
- 역할: fatigue 적분/건전도 계산
- 핵심 함수: `update_fatigue_index` line 21

5) `utils.py`
- 역할: 전압/손실/회생 공통 계산
- 핵심 함수:
  - `compute_battery_voltage` line 70
  - `compute_component_losses` line 109

5.3 MDP 계층

1) `observations/phm_raw.py`
- 역할: 관측 텐서 구성
- 핵심: realobs budget/thermal stress 함수

2) `rewards/phm.py`
- 역할: PHM reward 함수
- 핵심: `thermal_margin_reward_realobs`, `electrical_energy_reward`

3) `terminations/health.py`
- 역할: 안전 종료 판정
- 핵심: `thermal_runaway`, `motor_stall`

========================================================================
6. 실로봇 로그 연동 상세(어디서 뭘 바꾸는지까지)
========================================================================

6.1 SDK 배치/검증

- 기본 SDK 위치:
  `<repo>/third_party/unitree_sdk2`
- 검증 스크립트:
  `unitree_go2_phm/scripts/real/check_sdk_setup.py`
- 핵심 검증 함수:
  `validate_sdk_root(...)` line 59

실행 예:
`python3 unitree_go2_phm/scripts/real/check_sdk_setup.py --target-arch auto`

6.2 SDK 경량화(선택)

- 스크립트:
  `unitree_go2_phm/scripts/real/prune_sdk2_for_go2.py`
- 목적: Go2 관련 예제만 남겨 빌드/관리 단순화

6.3 브릿지 빌드/실행

- C++ 브릿지:
  `unitree_go2_phm/scripts/real/sdk2_bridge/go2_udp_bridge.cpp`

브릿지 역할:
1) LowState 수신 (`LowStateHandler`, line 385)
2) 12모터 temp max, pack/cell 추출 (`FromLowState`, line 214)
3) 50Hz state 송신 (`SendState`, line 432)
4) Python 명령 수신/적용 (`PollCommands` line 394, `ApplyCommand` line 417)

6.4 live governor 실행

- 스크립트:
  `unitree_go2_phm/scripts/real/run_governor_live_template.py`
- 핵심:
  - 패킷 파싱: `_parse_state_packet` line 165
  - 윈도우 집계: `aggregate_window` line 197
  - governor step 적용: line 487
  - stop reason 분류: `classify_stop_reason` line 228

6.5 로그 변환/오프라인 검증

1) raw 500Hz -> replay 50Hz
- `log_to_replay_csv.py:71`
- 규칙:
  - temp_max: window max
  - vcell_min: window min
  - vpack/cmd: window last

2) offline governor eval
- `offline_governor_eval_from_log.py:128`
- 결과:
  - hard_stop 여부/원인
  - mean scale
  - warn 이상 온도 노출시간

========================================================================
7. "코드 근거/질의"에서 자주 나오는 핵심 질문 30개
========================================================================

Q1) Baseline과 PHM 차이는 정확히 어디서 갈리나?
- A1) `baseline_env_cfg.py`에서 PHM obs/reward 제거한 줄이 명시돼 있습니다.

Q2) RealObs가 truly real-observable인지 어떻게 보장하나?
- A2) 관측은 `realobs_env_cfg.py`에서 측정 기반 함수만 넣었고, brownout도 sensor voltage로 강제합니다.

Q3) thermal semantics 혼동을 어떻게 막나?
- A3) 평가 결과에 semantics key와 meta를 같이 저장합니다(`evaluate.py:859-873`).

Q4) done 직후 metric 리셋 오염은?
- A4) terminal snapshot을 우선 사용합니다(`evaluate.py:598` 이후).

Q5) governor 수식 SSOT는?
- A5) `replay_utils.py` `ThermalVoltageGovernor.step`입니다.

Q6) live/offline governor가 replay와 다르게 동작하지 않나?
- A6) replay_utils import 가능 시 동일 클래스를 재사용하고, 실패 시 fallback 수식도 동일 파라미터로 구현되어 있습니다.

Q7) distill에서 dynamics alignment를 왜 기본 off?
- A7) student task semantics 보존이 메인 claim에 유리해서입니다.

Q8) alignment all을 쓰면 뭐가 바뀌나?
- A8) brownout/thermal termination 파라미터를 teacher 쪽으로 복사합니다(`distill_teacher_student.py:226-252`).

Q9) fatigue는 어디서 적분되나?
- A9) `degradation.py:update_fatigue_index`에서 dt 적분됩니다.

Q10) 온도는 어디서 적분되나?
- A10) `thermal.py:update_motor_temperature`에서 coil/case node를 dt 적분합니다.

Q11) PHM 상태 초기화는?
- A11) `interface.py:init_phm_interface`에서 PHMState 생성합니다.

Q12) reset 직후 왜 센서 refresh를 또 하나?
- A12) reset 직후 zero-noise 상태를 방지해 학습 편향을 줄이기 위함입니다(`unitree_go2_phm_env.py:506-511`).

Q13) brownout은 어떤 전압으로 판단하나?
- A13) cfg의 `brownout_voltage_source`를 따릅니다.

Q14) RealObs에선 왜 sensor voltage?
- A14) 실측 채널 중심 claim과 일치시키기 위해서입니다.

Q15) stop reason은 어디서 남나?
- A15) replay/live/offline 각 스크립트에서 reason 문자열로 저장합니다.

Q16) reward tuning advisor는 자동수정하나?
- A16) 아니요. 추천/게이트만 출력하고 파일 자동수정은 하지 않습니다.

Q17) 추천 weight가 이상하면?
- A17) gate 모드에서 baseline 대비 기준 미달이면 rollback 권고합니다.

Q18) curriculum 급변 문제는 해결됐나?
- A18) hybrid ramp + performance gate로 완화돼 있습니다(`interface.py:639`).

Q19) scenario injection이 task마다 강도 다르다는데?
- A19) case-proxy termination 활성일 때 immediate fail 방지를 위해 critical/aged 주입 온도를 조정합니다(`evaluate.py:406-418`).

Q20) 그럼 비교가 불공정 아님?
- A20) semantics가 다르기 때문에 메타와 캡션에 명시해 해석 오해를 방지합니다.

Q21) RealObs thermal reward와 warn 차이 있나?
- A21) 현재 RealObs는 warn 65로 통일했습니다(`realobs_env_cfg.py:108`).

Q22) fault injection은 reproducible한가?
- A22) leg/kp/kd/start time을 고정 인자로 주기 때문에 재현됩니다.

Q23) 실로봇에서 고정 커맨드 replay 가능한가?
- A23) bridge+live governor에서 schedule 파일 기반으로 가능합니다.

Q24) 실로봇 로그 최소 컬럼은?
- A24) timestamp, cmd(vx/vy/wz), 12모터 temp, pack voltage, 8셀 voltage입니다.

Q25) 500Hz 데이터를 왜 50Hz로 내리나?
- A25) 정책/거버너 제어 루프를 50Hz로 맞춰 비교 일관성을 유지하기 위함입니다.

Q26) 논문 메인 테이블은 어느 task 기준?
- A26) RealObs 기준이 메인이고, PHM privileged는 상한선 보조표로 배치합니다.

Q27) Teacher-Student를 PHM 학회에 써도 되나?
- A27) 됩니다. 단, 메인 claim은 RealObs 학생 성능과 안전지표 개선으로 두는 게 안전합니다.

Q28) IROS 타겟이면?
- A28) 로봇실험 비중을 늘리고, distill은 실용적 obs-gap 해결 기법으로 강조하는 편이 유리합니다.

Q29) 지금 코드가 완벽한가?
- A29) 코드 레벨 정합성은 높지만 실상수 보정 전엔 절대성능 claim을 보수적으로 해야 합니다.

Q30) 다음 액션 1순위는?
- A30) 실로그 수집 -> 상수보정 -> 동일 프로토콜 재평가 순서입니다.

========================================================================
8. 실상수(Real Constants) 보정 체크리스트
========================================================================

8.1 반드시 실데이터로 다시 맞출 항목

1) 온도 경계
- `temp_warn_c`, `temp_crit_c`, `temp_stop_c`
- 위치:
  - replay governor cfg
  - live/offline governor args
  - RealObs reward/termination params

2) 전압 경계
- `cell_warn_v`, `cell_scale_stop_v`, `cell_hard_stop_v`, `pack_hard_stop_v`
- 위치:
  - replay_utils GovernorConfig
  - evaluate_replay CLI default
  - live/offline governor CLI default

3) 필터/예측 파라미터
- `temp_filter_tau_s`, `cell_filter_tau_s`, `pack_filter_tau_s`, `temp_prediction_horizon_s`

4) coil-case 오프셋
- `coil_to_case_delta_c`
- 위치:
  - evaluate semantics/termination
  - realobs observation/reward/termination
  - replay temp fallback

8.2 보정 후 반드시 재검증할 지표

1) safety
- hard_stop rate
- time over warn
- min vpack/vcell

2) performance
- survival
- mean_tracking_error_xy
- yaw_mae_exec

3) efficiency
- mean power
- total energy

========================================================================
9. 교수님 발표용 "한 문장 요약" 세트
========================================================================

1) "이 프로젝트는 열화 상태에서 무너지지 않는 보행정책을 만드는 연구입니다."
2) "코드상 PHM은 로깅이 아니라 실제 제어권(Kp/Kd/limit)을 바꾸는 모듈입니다."
3) "비교군은 같은 물리에서 정보만 제거해 공정하게 설계했습니다."
4) "메인 claim은 실측채널 기반 RealObs 결과로 제한합니다."
5) "temperature semantics는 case/coil을 분리 저장해 표 해석 충돌을 막았습니다."
6) "governor는 온도/전압 위험 중 더 큰 쪽을 따라 감속하고, hard-stop 사유를 분리 기록합니다."
7) "teacher-student는 observation gap을 줄이는 사전학습이고, 최종 성능 판단은 student 재학습 결과입니다."
8) "남은 핵심은 실로그 기반 상수 보정과 반복실험 분산 보고입니다."
9) "코드 실행 경로와 수정 포인트는 문서에 함수 단위로 맵핑돼 있어 바로 질의 대응 가능합니다."
10) "승인해주시면 2주 내 논문용 표/그림까지 고정 가능합니다."

========================================================================
10. 2주 실행 플랜(코드 파일 기준)
========================================================================

Day 1-2: 실로그 수집/점검
- check:
  `scripts/real/check_sdk_setup.py`
- run bridge + live governor dry run

Day 3: raw->50Hz 변환
- `scripts/real/log_to_replay_csv.py`

Day 4: offline governor sweep
- `scripts/real/offline_governor_eval_from_log.py`
- 파라미터 sweep로 안정구간 찾기

Day 5-6: 시뮬 재평가
- `scripts/rsl_rl/evaluate.py`
- `scripts/rsl_rl/evaluate_replay.py`

Day 7-8: distill + student finetune
- `scripts/rsl_rl/distill_teacher_student.py`
- `scripts/rsl_rl/train.py --task Unitree-Go2-RealObs-v1 --resume ...`

Day 9-10: ablation 최소셋
- align none vs all
- governor on/off
- fault 강도 2~3점

Day 11-12: 표/그림/캡션 확정
- semantics 명시 확인
- stop reason 표 추가

Day 13-14: 교수님 재발표 + 논문 초안 반영

========================================================================
11. 부록 A: 함수 책임 인덱스(빠른 검색용)
========================================================================

11.1 train/eval/distill/replay
- `train.py:127` main
- `evaluate.py:387` apply_scenario
- `evaluate.py:533` run_evaluation
- `evaluate.py:804` main
- `evaluate_replay.py:329` main
- `distill_teacher_student.py:206` alignment
- `distill_teacher_student.py:256` main

11.2 env/phm
- `unitree_go2_phm_env.py:54` load_managers
- `unitree_go2_phm_env.py:231` _apply_physical_degradation
- `unitree_go2_phm_env.py:292` step
- `unitree_go2_phm_env.py:478` _reset_idx
- `unitree_go2_phm_env.py:540` _predict_instant_voltage_ivp
- `unitree_go2_phm_env.py:665` _compute_thermal_limits
- `interface.py:67` init_phm_interface
- `interface.py:124` clear_step_metrics
- `interface.py:146` refresh_phm_sensors
- `interface.py:181` update_phm_dynamics
- `interface.py:639` curriculum gate
- `interface.py:717` reset_phm_interface

11.3 models/mdp
- `thermal.py:29` update_motor_temperature
- `degradation.py:21` update_fatigue_index
- `utils.py:70` compute_battery_voltage
- `utils.py:109` compute_component_losses
- `phm_raw.py:124` available_voltage_budget_realobs
- `phm_raw.py:150` thermal_stress_realobs
- `rewards/phm.py:123` thermal_margin_reward_realobs
- `terminations/health.py:85` thermal_runaway

11.4 real
- `check_sdk_setup.py:59` validate_sdk_root
- `log_to_replay_csv.py:71` main
- `offline_governor_eval_from_log.py:128` main
- `run_governor_live_template.py:344` main
- `go2_udp_bridge.cpp:214` FromLowState
- `go2_udp_bridge.cpp:303` Run
- `go2_udp_bridge.cpp:417` ApplyCommand
- `go2_udp_bridge.cpp:432` SendState

========================================================================
12. 부록 B: 발표 직전 최종 점검표
========================================================================

12.1 내용 정합성
- [ ] task 정의(3종)와 발표 슬라이드 문구 일치
- [ ] distill 기본 align none 문구 반영
- [ ] RealObs warn/stop 임계값 문구 일치
- [ ] temperature semantics 캡션/표 주석 반영

12.2 코드-문서 동기화
- [ ] `EXPERIMENT_GUIDE.md`와 실행 명령 일치
- [ ] 리플레이 수식/임계값 문서값과 코드값 일치
- [ ] real scripts default 값과 발표값 일치

12.3 실험 신뢰성
- [ ] seed/ckpt/command_file 기록
- [ ] stop reason breakdown 포함
- [ ] 최소 2~3회 반복실험 분산 확인

========================================================================
끝
========================================================================
